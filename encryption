#include <iostream>
#include <vector>
#include <stdio.h>
#include <time.h>
#include <math.h>
#include <stdlib.h>
using namespace std;

long long gcd(long long a, long long b){ //нахождение НОДа
	if(b==0)
		return a;
	return gcd(b, a%b);
}

int powmod (int a, int b, int p) {
	int res = 1;
	while (b)
		if (b & 1)
			res = int (res * 1ll * a % p),  --b;
		else
			a = int (a * 1ll * a % p),  b >>= 1;
	return res;
}

bool is_prime(long long x){ //проверка на простоту
    if (x < 2) return 0;
	for (int f = 2; f * f <= x; f++){
        if (x % f == 0) return false;
	}
	return true;
}

int findprime(int m){ //поиск простого
   srand(time(NULL));
  int k=2;
  bool flag = 0;
  while (flag == 0){
     k = rand()%(m + 1000) + m;
     if (is_prime(k) == 1) flag = 1;
  }
  return k;
}


int generator (int p) { //генерация первообразного корня
	vector<int> fact;
	int phi = p-1;
	int n = phi;
	for (int i=2; i*i<=n; ++i)
		if (n % i == 0) {
			fact.push_back (i);
			while (n % i == 0)
				n /= i;
		}
	if (n > 1)
		fact.push_back (n);

	for (int res=2; res<=p; ++res) {
		bool ok = true;
		for (size_t i=0; i<fact.size() && ok; ++i)
			ok &= powmod(res, phi / fact[i], p) != 1;
		if (ok)  return res;
	}
	return -1;
}

int reste(int a, int d, int b, int c){
    int res=powmod(a,d,c)*(b%c);
    if (res >= c) res = res % c;
    return res;
}


int main(){
  srand(time(NULL));
  int M;
  cout << "write message:";
  cin >> M;
  int p=findprime(M);
  int g=generator(p);
  int x = rand()%(p-2) + 2;
  int y = powmod(g,x,p);
  cout << "Public key:" <<" y = " << y << "  p = " << p << "  g = " << g <<  "\n";
  cout << "Private key:" <<" x = " << x << "\n";
  int k = rand()%(p-2) + 2;
  long long int a = powmod(g,k,p);
  long long int b = reste(y,k,M,p);
  cout << "Encrypted message: a = " << a << "  b = " << b;
}
